# #1 - WRITING AND RUNNING SIMPLE DOCKER FILES

**Docker is a tool designed to make it easier to create, deploy, and run applications by using containers.** Containers allow a developer to package up an application with all of the parts it needs, such as libraries and other dependencies, and deploy it as one package. By doing so, thanks to the container, the developer can rest assured that the application will run on any other Linux machine regardless of any customized settings that machine might have that could differ from the machine used for writing and testing the code.
 
**In a way, Docker is a bit like a virtual machine. But unlike a virtual machine, rather than creating a whole virtual operating system, Docker allows applications to use the same Linux kernel** as the system that they're running on and only requires applications be shipped with things not already running on the host computer. This gives a **significant performance boost and reduces the size of the application**.

![https://docs.docker.com/engine/images/architecture.svg](https://docs.docker.com/engine/images/architecture.svg)


![https://miro.medium.com/max/492/1*MYX0ClbWoitxS0RNUVvj8A.png](https://miro.medium.com/max/492/1*MYX0ClbWoitxS0RNUVvj8A.png)


## Install

* [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)
* [https://docs.docker.com/engine/install/linux-postinstall/](https://docs.docker.com/engine/install/linux-postinstall/)

## Running first docker files
`docker run hello-world`

`docker build .`  

`docker build -t my_nginx .  `

`docker build -f my_nginx.Dockerfile -t my_nginx .  `

`docker run my_nginx`  

`docker run python:3.7 python -c "import sys; print(sys.version)"`  
`docker run python:2.7 bash -c "ls"`  

`docker run  jjanzic/docker-python3-opencv python -c "import cv2; print(cv2.__version__)"
4.5.0`

## Exposing ports

https://docs.docker.com/engine/reference/builder/#expose  
`docker build -t nginx .; docker run -p 8000:8000 nginx` 

*Definicija EXPOSE v Dockerfile je zgolj za dokumentacijo. Funkcionalno, moramo definirat -p ob docker run ukazu*  

## Mounting volumes

[https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)

Volumes are the **preferred mechanism for persisting data generated by and used by Docker containers**. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker... In addition, volumes are often a better choice than persisting data in a container’s writable layer, because **a volume does not increase the size of the containers using it**, and the volume’s contents exist outside the lifecycle of a given container.

**Mount volumes for data persistance**    
*In this case, database data files will live on host filesystem and will be mounted to the container. If we delete the container, we will not delete the data :)*  
`docker run -v /database_data:/var/lib/postgresql/data -p 5432:5432 postgres:10`

**Mount volumes for real time code updates**  
*When developing, our chosen text editor works on a file which is located on the host filesystem. Since we need to "apply changes" to the file in the container, volume mounts are the way to go!*  
`docker run -v $(pwd)/templates:/usr/share/nginx/html:ro -p 8000:8000 nginx` 

## Executing commands in container

[https://docs.docker.com/engine/reference/commandline/exec/](https://docs.docker.com/engine/reference/commandline/exec/)


*Lets find the target container id*  
`docker ps`

*Lets list the files in /usr/share/nginx/html (files in container!)*  
`docker exec -it <CONTAINERID> <COMMAND>`  
`docker exec -it <CONTAINERID> ls /usr/share/nginx/html`  


- Execute migrate command inside a running container:  
	`docker exec -it <some_django_container_id_or_name> python manage.py migrate`
	
- Run a container from some_django_image_name and run the command inside. When done, stop the container:  
	`docker run <some_django_image_name> python manage.py migrate`

- Dump postgres data to file:  
  `docker exec postgres pg_dump my_db | gzip >/backups/mydb.tar.gz`
	
	
- Build react based frontend and copy built files to filesystem:  
  `docker exec <node_frontend_container_name> npm run build`  
  `docker cp node_frontend_container_name:/build ./nginx/build`
	
## Built image sizes

Bigger images means:  

- longer build times  
- bigger images size (this can REALLY fill your disk)  
- (longer "*CI repo fetch*" time)  


### Using slim/alpine base images
Use "-alpine" images if possible. Observe the reduced image size

```
docker image ls | grep nginx
nginx:1.17.3-alpine			21.2MB   
nginx:1.17.3				126MB
```

### Reduce image layers

Produces 3 layers on top of base image:   

```
FROM ubuntu:21.04
RUN apt-get update && apt-get install -y libcairo2  # <-- layer 1
RUN apt-get update && apt-get install -y libpango   # <-- layer 2
RUN apt-get update && apt-get install -y gettext    # <-- layer 3
```

Produces 1 layer on top of base image:

```
FROM ubuntu:21.04
RUN apt-get update && apt-get install -y \
	libcairo2\
	libpango\
	gettext    # <-- layer 1
```


### Use .dockerignore 

* [Nekaj razlage o .dockerignore](https://codefresh.io/docker-tutorial/not-ignore-.dockerignore -2/)
* [.dockerignore  syntax & docs](https://docs.docker.com/engine/reference/builder/### -file)

Containers should be minimal contain only what is neccessary to run the app.
Observe increased image size when adding big files to a container.  

```
cp <some_big_file_on_my_FS> ./templates  
docker build -t nginx .

=> transferring context: 136.42MB  
docker image ls | grep nginx  
```
	

Tipicno se to zgodi, ko se v sliki znajdejo direktoriji .git, node_modules...  
Zato bodi natancen in ekspliciten pri uporabi `COPY` ukazov. V sliko skopiraj minilalno kar je potrebno!
Za 'excludanje' izjem, upodabi .dockerignore

```
echo "templates/<some_big_file_on_my_FS>" >> .dockerignore  
docker build -t nginx .  
docker image ls | grep nginx
```

Dont include secrets and unneccesary files:

```
FROM nginx:1.17.3-alpine
COPY ./* /app

docker build ...
docker run ...
docker exec -it <some_id> ls -l /app
.git   # Git has nothing to do with the container. Put to .dockerignore!
.env   # Secrets built into the container. Bad idea, put to .dockerignore!
templates
modules
...
```

## Using container registries
[https://docs.docker.com/registry/](https://docs.docker.com/registry/)

Gitlab > Start Project > Packages & Registries > copy CLI commands

```
docker login registry.gitlab.com

docker build -t <repository>/<tag>:<version>
docker build -t registry.gitlab.com/mihagrgicjelen/docker-workshop-test-registry/my-nginx:v1 .

docker push <repository>/<tag>:<version>
docker push registry.gitlab.com/mihagrgicjelen/docker-workshop-test-registry/my-nginx:v1
```
Always define image tags, dont use null or 'latest'


## Restart policies

[https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy](https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy)

```
no
on-failure
always
unless-stopped
```

```
docker run --restart on-failure redis /bin/bash -c "sleep 5; exit 0"
watch docker ps  # to monitor whats going on
```

## Commands

### Docker CLI
```
docker build -t <tag> -f <dockerfile> <context>
docker build -t the_might_nginx -f nginx.Dockerfile .

docker run <the_image> <command>
docker run --name <container_name> --network=<network_name> -p <external_port>:<internal_port> <image_name>

docker pull <public_image_name>:<version>
docker push <repository>/<tag>:<version>

docker exec <container_id> <command>
docker run <container_id> <command>

docker ps
watch docker ps
docker stop $(docker ps -q)  # stop all running containers
docker image ls
docker volume ls
docker network ls
docker stats
```


### .Dockerfile

- [FROM](https://docs.docker.com/engine/reference/builder/#from)
- [COPY](https://docs.docker.com/engine/reference/builder/#copy)
- [ADD](https://docs.docker.com/engine/reference/builder/#copy)
- [WORKDIR](https://docs.docker.com/engine/reference/builder/#workdir)
- [CMD](https://docs.docker.com/engine/reference/builder/#copy)
- [EXPOSE](https://docs.docker.com/engine/reference/builder/#copy)
- [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#copy)
- [ARG](https://docs.docker.com/engine/reference/builder/#copy)
- [ENV](https://docs.docker.com/engine/reference/builder/#copy)


# Docker-compose

[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)  

[https://docs.docker.com/compose/](https://docs.docker.com/compose/)

Compose is a tool for **defining and running multi-container Docker applications**. With Compose, you *use a YAML file to configure your application’s services*. Then, with a **single command**, you **create and start all the services** from your configuration.


Aliases to make your life easier, when working with compose files:  
*(put to bash_profile file  --> `nano ~/.bash_profile`)*

```
alias stopall='docker stop $(docker ps -q)'  
alias dc='docker-compose'  
alias d='docker'  
alias dcdev='docker-compose -f docker-compose.yml -f docker-compose-DEV.yml'  
alias dcdevb='docker-compose -f docker-compose.yml -f docker-compose-DEV.yml -f docker-compose-BUILD.yml'  
```
